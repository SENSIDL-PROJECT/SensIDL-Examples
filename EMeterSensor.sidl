/* *
 * In diesem Beispiel soll die Beschreibung von EMeter durch SensIDL illustrieren. Als Anwendungsszenario wird auf
 * Empfängerseite ein C#-Client angenommen, der mit dem auf C basierenden Modul von EMeter kommuniziert.  
 */

/* *
 * Über die Optionen wird festgelegt, das der generierte Code auf Empfängerseite in C# und auf Sensorseite in C 
 * generiert wird.
 */
datamodel { 
	options {
		receiver language: JAVA
		sensor language: JAVA
	}
	
	/* *
	 * Deklaration von verschiedenen Repräsentationen die bestimmte Daten besitzen können. 
	 */
	repr oneByteByte is 1 byte in CHAR
	repr oneByteInt8 is 1 byte in INT
	repr twoByteInt16 is 2 bytes in INT 
	repr fourByteFloat is 4 bytes in FLOAT
	repr fourteenByteByte is 14 bytes in CHAR
	repr fourByteInt32 is 4 bytes in INT
	
	/* *
	 * Beschreibung der Phase L1 
	 */
	structure L1 {
		structure Data {
			
			/* *
	 		 * In dieser Struktur werden die Metadaten von L1 gruppiert. Diese entsprechen den ersten zwei Bytes
	 		 * in der EMeter-Datenstruktur.
	 		 */
			structure Metadata {
				const CHAR DeviceType as oneByteByte
				const CHAR RecordType as oneByteByte
			}
			
			/* *
	 		 * In dieser Struktur werden die gemessenen Werte von L1 gruppiert. Diese entsprechen den Bytes 3-12
	 		 * in der EMeter-Datenstruktur. Zusätzlich kann optional die Bitwertigkeit angegeben werden.
	 		 */
			structure MeasuredValues {
				data of Voltage in "V" as twoByteInt16 with bit numbering MSB
				data of CurrentIntensity in "A" as fourByteFloat with bit numbering MSB
				data of Energy in "Ws" as fourByteFloat with bit numbering MSB
				data of CosPhi as oneByteInt8
			}
			
			/* *
	 		 * In dieser Struktur wird die Messnummer von L1 deklariert. Diese entspricht dem letzen Byte.
	 		 */
			structure RecordData {
				const CHAR RecordNo as oneByteByte
			}
		}
	}
	
	/* *
	 * Der Teil "Coding_L1" soll schließlich die Kodierungsverfahren repräsentieren. Hierbei werden die Methoden
	 * "structToByte" und "byteToStruct" generiert, welche für die Kodierung und Dekodierung verantwortlich sind. 
	 */
	calculate Coding_L1
		as fourteenByteByte
		by structToByte, byteToStruct
		with (L1 as BYTE_ARRAY)
	
	/* *
	 * Siehe Phase L1 
	 */	
	structure L2 {
		structure Data {
			structure Metadata {
				const CHAR DeviceType as oneByteByte
				const CHAR RecordType as oneByteByte
			}
			
			structure MeasuredValues {
				data of Voltage in "V" as twoByteInt16 with bit numbering MSB
				data of CurrentIntensity in "A" as fourByteFloat with bit numbering MSB
				data of Energy in "Ws" as fourByteFloat with bit numbering MSB
				data of CosPhi as oneByteInt8
			}
			
			structure RecordData {
				const CHAR RecordNo as oneByteByte
			}
		}
	}
	
	/* *
	 * Siehe Coding_L1 
	 */
	calculate Coding_L2
		as fourteenByteByte
		by structToByte, byteToStruct
		with (L2 as BYTE_ARRAY)
	
	/* *
	 * Siehe Phase L1 
	 */	
	structure L3 {
		structure Data {
			structure Metadata {
				const CHAR DeviceType as oneByteByte
				const CHAR RecordType as oneByteByte
			}
			
			structure MeasuredValues {
				data of Voltage in "V" as twoByteInt16
				data of CurrentIntensity in "A" as fourByteFloat
				data of Energy in "Ws" as fourByteFloat with bit numbering MSB
				data of CosPhi as oneByteInt8
			}
			
			structure RecordData {
				const CHAR RecordNo as oneByteByte
			}
		}
	}
	
	/* *
	 * Siehe Coding_L1 
	 */
	calculate Coding_L3
		as fourteenByteByte
		by structToByte, byteToStruct
		with (L3 as BYTE_ARRAY)
	
	
	/* *
	 * Siehe Phase L1...L3 
	 */	
	structure N {
		structure Data {
			
			structure Metadata {
				const CHAR DeviceType as oneByteByte
				const CHAR RecordType as oneByteByte
			}
			
			structure MeasuredValues {
				data of Dummy as twoByteInt16
				data of CurrentIntensity in "A" as fourByteFloat with bit numbering MSB
				data of Dummy1 as fourByteInt32
				data of CosPhi as oneByteInt8
			}
			
			structure RecordData {
				const CHAR RecordNo as oneByteByte
			}
		}
	}
	
	/* *
	 * Siehe Coding_L1...L3 
	 */	
	calculate Coding_N
		as fourteenByteByte
		by structToByte, byteToStruct
		with (N as BYTE_ARRAY)
	
	/* *
	 * Beschreibung der bezogenen Energiemenge L1,L2,L3.
	 */
	structure Energy {
		structure Data {
			/* *
	 		 * In dieser Gruppe werden die Metadaten gruppiert. Diese entsprechen den ersten zwei Bytes
	 		 * in der EMeter-Datenstruktur.
	 		 */
			structure Metadata {
				const CHAR DeviceType as oneByteByte
				const CHAR RecordType as oneByteByte
			}
			
			/* *
	 		 * In dieser Gruppe werden die Messwerte gruppiert und entsprechen den Bytes 3-14.
	 		 */
			structure MeasuredValues {
				data of fE_L1 in "kWh" as fourByteFloat with bit numbering MSB
				data of fE_L2 in "kWh" as fourByteFloat with bit numbering MSB
				data of fE_L3 in "kWh" as fourByteFloat with bit numbering MSB
			}
		}
	}
	
	/* *
	 * Siehe Coding_L1...L3 oder Coding_N 
	 */	
	calculate Coding_Energy
		as fourteenByteByte 
		by structToByte, byteToStruct
		with (Energy as BYTE_ARRAY)
	
	/* *
	 * Letztlich sollen die fünf Datenpackete übermittelt werden. 
	 */	
	transmit
		Coding_L1,
		Coding_L2,
		Coding_L3,
		Coding_N,
		Coding_Energy
}